{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyquil-for-azure-quantum This library allows you to use pyQuil to run programs on Azure Quantum against Rigetti targets. Internally, it leverages the azure-quantum package. Usage Generally, you use pyQuil normally, with a few differences: Instead of pyquil.get_qc() , you will use either pyquil_azure_quantum.get_qvm() or pyquil_azure_quantum.get_qpu() . You do not need to have qvm or quilc running in order to run programs through pyquil_azure_quantum . You may still run them if you wish to run QVM locally instead of passing through Azure or if you wish to precompile your programs (e.g., to inspect the exact Quil that will run). You do not need a QCS account or credentials unless you wish to manually inspect the details of the QPU (e.g., list all qubits). You must have these environment variables set: AZURE_QUANTUM_SUBSCRIPTION_ID : The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG : The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME : The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION : The region where the Quantum Workspace is located. You may set environment variables to authenticate with Azure. If you do not, a browser will open to the Azure portal to authenticate. Whenever possible, you should prefer using AzureQuantumComputer.run_batch() over Program.write_memory(); AzureQuantumComputer.run() to run programs which have multiple parameters. Calling write_memory() followed by run() will still work but will be much slower than running a batch of parameters all at once. Examples 1. Leveraging Hosted QVM and quilc With this program, you do not need to run qvm nor quilc locally in order to leverage them, as they can run through Azure Quantum. from pyquil_for_azure_quantum import get_qpu , get_qvm from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) qvm = get_qvm () exe = qpu . compile ( program ) # This does not run quilc yet. results = qpu . run ( exe ) # Quilc will run in the cloud before executing the program. qvm_results = qvm . run ( exe ) # This runs the program on QVM in the cloud, not locally. 2. Running quilc Locally You can optionally run quilc yourself and disable the use of quilc in the cloud. from pyquil_for_azure_quantum import get_qpu from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) native_quil = qpu . compiler . quil_to_native_quil ( program ) # quilc must be running locally to compile exe = qpu . compile ( native_quil , to_native_gates = False ) # Skip quilc in the cloud results = qpu . run ( exe ) 3. Running Parametrized Circuits in a Batch When you have a program which should be run across multiple parameters, you can submit all the parameters at once to significantly improve performance. import numpy as np from pyquil_for_azure_quantum import get_qpu from pyquil.gates import MEASURE , RX from pyquil.quil import Program from pyquil.quilbase import Declare from pyquil.quilatom import MemoryReference program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) compiled = qpu . compile ( program ) memory_map = { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]} results = qpu . run_batch ( compiled , memory_map ) # This is a list of results, one for each parameter set. results_0 = results [ 0 ] . readout_data [ \"ro\" ] results_pi = results [ 1 ] . readout_data [ \"ro\" ] results_2pi = results [ 2 ] . readout_data [ \"ro\" ] Microsoft, Microsoft Azure, and Azure Quantum are trademarks of the Microsoft group of companies.","title":"Home"},{"location":"#pyquil-for-azure-quantum","text":"This library allows you to use pyQuil to run programs on Azure Quantum against Rigetti targets. Internally, it leverages the azure-quantum package.","title":"pyquil-for-azure-quantum"},{"location":"#usage","text":"Generally, you use pyQuil normally, with a few differences: Instead of pyquil.get_qc() , you will use either pyquil_azure_quantum.get_qvm() or pyquil_azure_quantum.get_qpu() . You do not need to have qvm or quilc running in order to run programs through pyquil_azure_quantum . You may still run them if you wish to run QVM locally instead of passing through Azure or if you wish to precompile your programs (e.g., to inspect the exact Quil that will run). You do not need a QCS account or credentials unless you wish to manually inspect the details of the QPU (e.g., list all qubits). You must have these environment variables set: AZURE_QUANTUM_SUBSCRIPTION_ID : The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG : The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME : The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION : The region where the Quantum Workspace is located. You may set environment variables to authenticate with Azure. If you do not, a browser will open to the Azure portal to authenticate. Whenever possible, you should prefer using AzureQuantumComputer.run_batch() over Program.write_memory(); AzureQuantumComputer.run() to run programs which have multiple parameters. Calling write_memory() followed by run() will still work but will be much slower than running a batch of parameters all at once.","title":"Usage"},{"location":"#examples","text":"","title":"Examples"},{"location":"#1-leveraging-hosted-qvm-and-quilc","text":"With this program, you do not need to run qvm nor quilc locally in order to leverage them, as they can run through Azure Quantum. from pyquil_for_azure_quantum import get_qpu , get_qvm from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) qvm = get_qvm () exe = qpu . compile ( program ) # This does not run quilc yet. results = qpu . run ( exe ) # Quilc will run in the cloud before executing the program. qvm_results = qvm . run ( exe ) # This runs the program on QVM in the cloud, not locally.","title":"1. Leveraging Hosted QVM and quilc"},{"location":"#2-running-quilc-locally","text":"You can optionally run quilc yourself and disable the use of quilc in the cloud. from pyquil_for_azure_quantum import get_qpu from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) native_quil = qpu . compiler . quil_to_native_quil ( program ) # quilc must be running locally to compile exe = qpu . compile ( native_quil , to_native_gates = False ) # Skip quilc in the cloud results = qpu . run ( exe )","title":"2. Running quilc Locally"},{"location":"#3-running-parametrized-circuits-in-a-batch","text":"When you have a program which should be run across multiple parameters, you can submit all the parameters at once to significantly improve performance. import numpy as np from pyquil_for_azure_quantum import get_qpu from pyquil.gates import MEASURE , RX from pyquil.quil import Program from pyquil.quilbase import Declare from pyquil.quilatom import MemoryReference program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) compiled = qpu . compile ( program ) memory_map = { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]} results = qpu . run_batch ( compiled , memory_map ) # This is a list of results, one for each parameter set. results_0 = results [ 0 ] . readout_data [ \"ro\" ] results_pi = results [ 1 ] . readout_data [ \"ro\" ] results_2pi = results [ 2 ] . readout_data [ \"ro\" ] Microsoft, Microsoft Azure, and Azure Quantum are trademarks of the Microsoft group of companies.","title":"3. Running Parametrized Circuits in a Batch"},{"location":"api_reference/","text":"Run pyquil programs through Azure Quantum Usage Instead of using pyquil.get_qc() use pyquil_for_azure_quantum.get_qpu() for QPUs and pyquil_for_azure_quantum.get_qvm() for QVM. QVM and quilc do not need to be installed or running locally. AzureJob dataclass Keeps track of an AzureProgram that was submitted to Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 188 189 190 191 192 193 @dataclass class AzureJob : \"\"\"Keeps track of an ``AzureProgram`` that was submitted to Azure Quantum.\"\"\" job : Job executable : AzureProgram AzureProgram Bases: ObjectProxy , Program A wrapper around a Program that is used to execute on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class AzureProgram ( ObjectProxy , Program ): # type: ignore \"\"\"A wrapper around a ``Program`` that is used to execute on Azure Quantum.\"\"\" def __init__ ( self , program : Program , skip_quilc : bool , memory_map : Optional [ Dict [ str , List [ List [ ParamValue ]]]] = None , ) -> None : super () . __init__ ( program ) self . skip_quilc = skip_quilc self . memory_map = memory_map def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc ) def get_memory ( self ) -> Optional [ Dict [ str , List [ List [ ParamValue ]]]]: \"\"\"Retrieve the memory map for this program formatted in the way that Azure expects\"\"\" if self . memory_map is not None : return self . memory_map memory = self . _memory . values if len ( memory ) == 0 : return None memory_indexes_and_values_per_name : Dict [ str , List [ Tuple [ int , ParamValue ]]] = {} for ref , value in memory . items (): if ref . name not in memory_indexes_and_values_per_name : memory_indexes_and_values_per_name [ ref . name ] = [] memory_indexes_and_values_per_name [ ref . name ] . append (( ref . index , value )) memory_indexes_and_values_per_name = { k : sorted ( v , key = lambda x : x [ 0 ]) for k , v in memory_indexes_and_values_per_name . items () } substitutions : Dict [ str , List [ List [ float ]]] = {} for name , indexes_and_values in memory_indexes_and_values_per_name . items (): values = [] expected_index = 0 for index , value in indexes_and_values : while index != expected_index : # Pad missing values with zeros, just like pyquil does when patching values . append ( 0.0 ) expected_index += 1 values . append ( value ) expected_index += 1 substitutions [ name ] = [ values ] return substitutions copy () Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. Source code in pyquil_for_azure_quantum/__init__.py 55 56 57 58 59 60 61 def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc ) get_memory () Retrieve the memory map for this program formatted in the way that Azure expects Source code in pyquil_for_azure_quantum/__init__.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_memory ( self ) -> Optional [ Dict [ str , List [ List [ ParamValue ]]]]: \"\"\"Retrieve the memory map for this program formatted in the way that Azure expects\"\"\" if self . memory_map is not None : return self . memory_map memory = self . _memory . values if len ( memory ) == 0 : return None memory_indexes_and_values_per_name : Dict [ str , List [ Tuple [ int , ParamValue ]]] = {} for ref , value in memory . items (): if ref . name not in memory_indexes_and_values_per_name : memory_indexes_and_values_per_name [ ref . name ] = [] memory_indexes_and_values_per_name [ ref . name ] . append (( ref . index , value )) memory_indexes_and_values_per_name = { k : sorted ( v , key = lambda x : x [ 0 ]) for k , v in memory_indexes_and_values_per_name . items () } substitutions : Dict [ str , List [ List [ float ]]] = {} for name , indexes_and_values in memory_indexes_and_values_per_name . items (): values = [] expected_index = 0 for index , value in indexes_and_values : while index != expected_index : # Pad missing values with zeros, just like pyquil does when patching values . append ( 0.0 ) expected_index += 1 values . append ( value ) expected_index += 1 substitutions [ name ] = [ values ] return substitutions AzureQuantumComputer Bases: QuantumComputer A pyquil.QuantumComputer that runs on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class AzureQuantumComputer ( QuantumComputer ): \"\"\" A ``pyquil.QuantumComputer`` that runs on Azure Quantum. \"\"\" def __init__ ( self , * , target : str , qpu_name : str ): qam = AzureQuantumMachine ( target = target ) compiler = Proxy ( lambda : get_qc ( qpu_name ) . compiler ) super () . __init__ ( name = qpu_name , qam = qam , compiler = compiler ) # pylint: disable-next=no-self-use,unused-argument def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]]) -> List [ QAMExecutionResult ]: \"\"\"Run a sequence of memory values through the program. See Also: * [`AzureQuantumMachine.run_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.run_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) return qam . run_batch ( executable , memory_map ) compile ( program , to_native_gates = True , optimize = True , * , protoquil = None ) Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass False to to_native_gates . This is necessary when utilizing Quil-T. If you want to run quilc locally in order to check the Native Quil which will be executed, call compiler.quil_to_native_quil and pass the result to this function along with to_native_gates=False . Parameters: Name Type Description Default program Program The program to compile. required to_native_gates bool Whether to convert the program to native gates by running quilc in the cloud prior to execution. Defaults to True , pass False to skip cloud-side quilc . True optimize bool Has no effect on Azure. True protoquil Optional [ bool ] Has no effect on Azure. None Returns: Type Description AzureProgram An AzureExecutable which is effectively a simple wrapper around a Program . No actual compilation is AzureProgram done here. Source code in pyquil_for_azure_quantum/__init__.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) run_batch ( executable , memory_map ) Run a sequence of memory values through the program. See Also AzureQuantumMachine.run_batch Source code in pyquil_for_azure_quantum/__init__.py 134 135 136 137 138 139 140 141 def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]]) -> List [ QAMExecutionResult ]: \"\"\"Run a sequence of memory values through the program. See Also: * [`AzureQuantumMachine.run_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.run_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) return qam . run_batch ( executable , memory_map ) AzureQuantumMachine Bases: QAM [ AzureJob ] An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables must be set AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class AzureQuantumMachine ( QAM [ AzureJob ]): \"\"\"An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables __must__ be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" def __init__ ( self , * , target : str ) -> None : self . _workspace = Workspace ( subscription_id = environ [ \"AZURE_QUANTUM_SUBSCRIPTION_ID\" ], resource_group = environ [ \"AZURE_QUANTUM_WORKSPACE_RG\" ], name = environ [ \"AZURE_QUANTUM_WORKSPACE_NAME\" ], location = environ [ \"AZURE_QUANTUM_WORKSPACE_LOCATION\" ], ) # noinspection PyTypeChecker self . _target = Rigetti ( workspace = self . _workspace , name = target , ) # pylint: disable-next=useless-super-delegation def run ( self , executable : AzureProgram ) -> QAMExecutionResult : # type: ignore[override] \"\"\"Run the executable and wait for its results\"\"\" return super () . run ( executable ) def execute ( self , executable : AzureProgram , name : str = \"pyquil-azure-job\" ) -> AzureJob : # type: ignore[override] \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , ) memory = executable . get_memory () if memory is not None : input_params . substitutions = memory job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) # pylint: disable-next=no-self-use def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () result = Result ( job ) numpified = { k : array ( v ) for k , v in result . data_per_register . items ()} return QAMExecutionResult ( executable = execute_response . executable , readout_data = numpified , ) def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]], name : str = \"pyquil-azure-job\" ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each set of parameters in the ``memory_map``. Args: executable: The AzureProgram to run. memory_map: A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. **All values (outer lists) must be of the same length**. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each set of parameters. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_batch(compiled, {\"theta\": [[0.0], [np.pi], [2 * np.pi]]}) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` \"\"\" num_params = None for param_name , param_values in memory_map . items (): if num_params is None : num_params = len ( param_values ) elif num_params != len ( param_values ): raise ValueError ( \"All parameter values must be of the same length. \" f \" { param_name } has length { len ( param_values ) } but { num_params } were expected.\" ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = memory_map ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) combined_result = self . get_result ( AzureJob ( job , executable )) if num_params is None or num_params == 1 : return [ combined_result ] split_results = split ( combined_result . readout_data [ \"ro\" ], num_params ) # type: ignore return [ QAMExecutionResult ( executable , { \"ro\" : result }) for result in split_results ] execute ( executable , name = 'pyquil-azure-job' ) Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a QuantumExecutable . You should build the AzureProgram via AzureQuantumComputer.compile . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required name str An optional name for the job which will show up in the Azure Quantum UI. 'pyquil-azure-job' Returns: Type Description AzureJob A Job which can be used to check the status of the job or retrieve a QAMExecutionResult via AzureJob get_result() . Source code in pyquil_for_azure_quantum/__init__.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def execute ( self , executable : AzureProgram , name : str = \"pyquil-azure-job\" ) -> AzureJob : # type: ignore[override] \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , ) memory = executable . get_memory () if memory is not None : input_params . substitutions = memory job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) get_result ( execute_response ) Wait for a Job to complete, then return the results Raises: Type Description RuntimeError If the job fails. Source code in pyquil_for_azure_quantum/__init__.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () result = Result ( job ) numpified = { k : array ( v ) for k , v in result . data_per_register . items ()} return QAMExecutionResult ( executable = execute_response . executable , readout_data = numpified , ) run ( executable ) Run the executable and wait for its results Source code in pyquil_for_azure_quantum/__init__.py 229 230 231 def run ( self , executable : AzureProgram ) -> QAMExecutionResult : # type: ignore[override] \"\"\"Run the executable and wait for its results\"\"\" return super () . run ( executable ) run_batch ( executable , memory_map , name = 'pyquil-azure-job' ) Run the executable for each set of parameters in the memory_map . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_map Dict [ str , List [ List [ float ]]] A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. All values (outer lists) must be of the same length . required name str An optional name for the job which will show up in the Azure Quantum UI. 'pyquil-azure-job' Returns: Type Description List [ QAMExecutionResult ] A list of QAMExecutionResult objects, one for each set of parameters. >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT , MEASURE , RX , H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm () >>> program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) >>> compiled = qvm . compile ( program ) >>> results = qvm . run_batch ( compiled , { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]}) >>> assert len ( results ) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results [ 0 ] . readout_data [ \"ro\" ] >>> assert len ( results_0 ) == 1000 # 1000 shots >>> assert np . mean ( results_0 ) == 0 >>> results_pi = results [ 1 ] . readout_data [ \"ro\" ] >>> assert len ( results_pi ) == 1000 >>> assert np . mean ( results_pi ) == 1 Source code in pyquil_for_azure_quantum/__init__.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]], name : str = \"pyquil-azure-job\" ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each set of parameters in the ``memory_map``. Args: executable: The AzureProgram to run. memory_map: A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. **All values (outer lists) must be of the same length**. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each set of parameters. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_batch(compiled, {\"theta\": [[0.0], [np.pi], [2 * np.pi]]}) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` \"\"\" num_params = None for param_name , param_values in memory_map . items (): if num_params is None : num_params = len ( param_values ) elif num_params != len ( param_values ): raise ValueError ( \"All parameter values must be of the same length. \" f \" { param_name } has length { len ( param_values ) } but { num_params } were expected.\" ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = memory_map ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) combined_result = self . get_result ( AzureJob ( job , executable )) if num_params is None or num_params == 1 : return [ combined_result ] split_results = split ( combined_result . readout_data [ \"ro\" ], num_params ) # type: ignore return [ QAMExecutionResult ( executable , { \"ro\" : result }) for result in split_results ] get_qpu ( qpu_name ) Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_qpu ( qpu_name : str ) -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = f \"rigetti.qpu. { qpu_name . lower () } \" , qpu_name = qpu_name ) get_qvm () Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def get_qvm () -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = \"rigetti.sim.qvm\" , qpu_name = \"qvm\" )","title":"Api reference"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureJob","text":"Keeps track of an AzureProgram that was submitted to Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 188 189 190 191 192 193 @dataclass class AzureJob : \"\"\"Keeps track of an ``AzureProgram`` that was submitted to Azure Quantum.\"\"\" job : Job executable : AzureProgram","title":"AzureJob"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureProgram","text":"Bases: ObjectProxy , Program A wrapper around a Program that is used to execute on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class AzureProgram ( ObjectProxy , Program ): # type: ignore \"\"\"A wrapper around a ``Program`` that is used to execute on Azure Quantum.\"\"\" def __init__ ( self , program : Program , skip_quilc : bool , memory_map : Optional [ Dict [ str , List [ List [ ParamValue ]]]] = None , ) -> None : super () . __init__ ( program ) self . skip_quilc = skip_quilc self . memory_map = memory_map def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc ) def get_memory ( self ) -> Optional [ Dict [ str , List [ List [ ParamValue ]]]]: \"\"\"Retrieve the memory map for this program formatted in the way that Azure expects\"\"\" if self . memory_map is not None : return self . memory_map memory = self . _memory . values if len ( memory ) == 0 : return None memory_indexes_and_values_per_name : Dict [ str , List [ Tuple [ int , ParamValue ]]] = {} for ref , value in memory . items (): if ref . name not in memory_indexes_and_values_per_name : memory_indexes_and_values_per_name [ ref . name ] = [] memory_indexes_and_values_per_name [ ref . name ] . append (( ref . index , value )) memory_indexes_and_values_per_name = { k : sorted ( v , key = lambda x : x [ 0 ]) for k , v in memory_indexes_and_values_per_name . items () } substitutions : Dict [ str , List [ List [ float ]]] = {} for name , indexes_and_values in memory_indexes_and_values_per_name . items (): values = [] expected_index = 0 for index , value in indexes_and_values : while index != expected_index : # Pad missing values with zeros, just like pyquil does when patching values . append ( 0.0 ) expected_index += 1 values . append ( value ) expected_index += 1 substitutions [ name ] = [ values ] return substitutions","title":"AzureProgram"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureProgram.copy","text":"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. Source code in pyquil_for_azure_quantum/__init__.py 55 56 57 58 59 60 61 def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc )","title":"copy()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureProgram.get_memory","text":"Retrieve the memory map for this program formatted in the way that Azure expects Source code in pyquil_for_azure_quantum/__init__.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_memory ( self ) -> Optional [ Dict [ str , List [ List [ ParamValue ]]]]: \"\"\"Retrieve the memory map for this program formatted in the way that Azure expects\"\"\" if self . memory_map is not None : return self . memory_map memory = self . _memory . values if len ( memory ) == 0 : return None memory_indexes_and_values_per_name : Dict [ str , List [ Tuple [ int , ParamValue ]]] = {} for ref , value in memory . items (): if ref . name not in memory_indexes_and_values_per_name : memory_indexes_and_values_per_name [ ref . name ] = [] memory_indexes_and_values_per_name [ ref . name ] . append (( ref . index , value )) memory_indexes_and_values_per_name = { k : sorted ( v , key = lambda x : x [ 0 ]) for k , v in memory_indexes_and_values_per_name . items () } substitutions : Dict [ str , List [ List [ float ]]] = {} for name , indexes_and_values in memory_indexes_and_values_per_name . items (): values = [] expected_index = 0 for index , value in indexes_and_values : while index != expected_index : # Pad missing values with zeros, just like pyquil does when patching values . append ( 0.0 ) expected_index += 1 values . append ( value ) expected_index += 1 substitutions [ name ] = [ values ] return substitutions","title":"get_memory()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer","text":"Bases: QuantumComputer A pyquil.QuantumComputer that runs on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class AzureQuantumComputer ( QuantumComputer ): \"\"\" A ``pyquil.QuantumComputer`` that runs on Azure Quantum. \"\"\" def __init__ ( self , * , target : str , qpu_name : str ): qam = AzureQuantumMachine ( target = target ) compiler = Proxy ( lambda : get_qc ( qpu_name ) . compiler ) super () . __init__ ( name = qpu_name , qam = qam , compiler = compiler ) # pylint: disable-next=no-self-use,unused-argument def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]]) -> List [ QAMExecutionResult ]: \"\"\"Run a sequence of memory values through the program. See Also: * [`AzureQuantumMachine.run_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.run_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) return qam . run_batch ( executable , memory_map )","title":"AzureQuantumComputer"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer.compile","text":"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass False to to_native_gates . This is necessary when utilizing Quil-T. If you want to run quilc locally in order to check the Native Quil which will be executed, call compiler.quil_to_native_quil and pass the result to this function along with to_native_gates=False . Parameters: Name Type Description Default program Program The program to compile. required to_native_gates bool Whether to convert the program to native gates by running quilc in the cloud prior to execution. Defaults to True , pass False to skip cloud-side quilc . True optimize bool Has no effect on Azure. True protoquil Optional [ bool ] Has no effect on Azure. None Returns: Type Description AzureProgram An AzureExecutable which is effectively a simple wrapper around a Program . No actual compilation is AzureProgram done here. Source code in pyquil_for_azure_quantum/__init__.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates )","title":"compile()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer.run_batch","text":"Run a sequence of memory values through the program. See Also AzureQuantumMachine.run_batch Source code in pyquil_for_azure_quantum/__init__.py 134 135 136 137 138 139 140 141 def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]]) -> List [ QAMExecutionResult ]: \"\"\"Run a sequence of memory values through the program. See Also: * [`AzureQuantumMachine.run_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.run_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) return qam . run_batch ( executable , memory_map )","title":"run_batch()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine","text":"Bases: QAM [ AzureJob ] An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables must be set AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class AzureQuantumMachine ( QAM [ AzureJob ]): \"\"\"An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables __must__ be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" def __init__ ( self , * , target : str ) -> None : self . _workspace = Workspace ( subscription_id = environ [ \"AZURE_QUANTUM_SUBSCRIPTION_ID\" ], resource_group = environ [ \"AZURE_QUANTUM_WORKSPACE_RG\" ], name = environ [ \"AZURE_QUANTUM_WORKSPACE_NAME\" ], location = environ [ \"AZURE_QUANTUM_WORKSPACE_LOCATION\" ], ) # noinspection PyTypeChecker self . _target = Rigetti ( workspace = self . _workspace , name = target , ) # pylint: disable-next=useless-super-delegation def run ( self , executable : AzureProgram ) -> QAMExecutionResult : # type: ignore[override] \"\"\"Run the executable and wait for its results\"\"\" return super () . run ( executable ) def execute ( self , executable : AzureProgram , name : str = \"pyquil-azure-job\" ) -> AzureJob : # type: ignore[override] \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , ) memory = executable . get_memory () if memory is not None : input_params . substitutions = memory job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) # pylint: disable-next=no-self-use def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () result = Result ( job ) numpified = { k : array ( v ) for k , v in result . data_per_register . items ()} return QAMExecutionResult ( executable = execute_response . executable , readout_data = numpified , ) def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]], name : str = \"pyquil-azure-job\" ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each set of parameters in the ``memory_map``. Args: executable: The AzureProgram to run. memory_map: A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. **All values (outer lists) must be of the same length**. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each set of parameters. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_batch(compiled, {\"theta\": [[0.0], [np.pi], [2 * np.pi]]}) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` \"\"\" num_params = None for param_name , param_values in memory_map . items (): if num_params is None : num_params = len ( param_values ) elif num_params != len ( param_values ): raise ValueError ( \"All parameter values must be of the same length. \" f \" { param_name } has length { len ( param_values ) } but { num_params } were expected.\" ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = memory_map ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) combined_result = self . get_result ( AzureJob ( job , executable )) if num_params is None or num_params == 1 : return [ combined_result ] split_results = split ( combined_result . readout_data [ \"ro\" ], num_params ) # type: ignore return [ QAMExecutionResult ( executable , { \"ro\" : result }) for result in split_results ]","title":"AzureQuantumMachine"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.execute","text":"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a QuantumExecutable . You should build the AzureProgram via AzureQuantumComputer.compile . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required name str An optional name for the job which will show up in the Azure Quantum UI. 'pyquil-azure-job' Returns: Type Description AzureJob A Job which can be used to check the status of the job or retrieve a QAMExecutionResult via AzureJob get_result() . Source code in pyquil_for_azure_quantum/__init__.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def execute ( self , executable : AzureProgram , name : str = \"pyquil-azure-job\" ) -> AzureJob : # type: ignore[override] \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , ) memory = executable . get_memory () if memory is not None : input_params . substitutions = memory job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable )","title":"execute()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.get_result","text":"Wait for a Job to complete, then return the results Raises: Type Description RuntimeError If the job fails. Source code in pyquil_for_azure_quantum/__init__.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () result = Result ( job ) numpified = { k : array ( v ) for k , v in result . data_per_register . items ()} return QAMExecutionResult ( executable = execute_response . executable , readout_data = numpified , )","title":"get_result()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.run","text":"Run the executable and wait for its results Source code in pyquil_for_azure_quantum/__init__.py 229 230 231 def run ( self , executable : AzureProgram ) -> QAMExecutionResult : # type: ignore[override] \"\"\"Run the executable and wait for its results\"\"\" return super () . run ( executable )","title":"run()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.run_batch","text":"Run the executable for each set of parameters in the memory_map . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_map Dict [ str , List [ List [ float ]]] A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. All values (outer lists) must be of the same length . required name str An optional name for the job which will show up in the Azure Quantum UI. 'pyquil-azure-job' Returns: Type Description List [ QAMExecutionResult ] A list of QAMExecutionResult objects, one for each set of parameters. >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT , MEASURE , RX , H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm () >>> program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) >>> compiled = qvm . compile ( program ) >>> results = qvm . run_batch ( compiled , { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]}) >>> assert len ( results ) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results [ 0 ] . readout_data [ \"ro\" ] >>> assert len ( results_0 ) == 1000 # 1000 shots >>> assert np . mean ( results_0 ) == 0 >>> results_pi = results [ 1 ] . readout_data [ \"ro\" ] >>> assert len ( results_pi ) == 1000 >>> assert np . mean ( results_pi ) == 1 Source code in pyquil_for_azure_quantum/__init__.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def run_batch ( self , executable : AzureProgram , memory_map : Dict [ str , List [ List [ float ]]], name : str = \"pyquil-azure-job\" ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each set of parameters in the ``memory_map``. Args: executable: The AzureProgram to run. memory_map: A dictionary mapping parameter names to lists of parameter values. Each value is a list as long as the number of slots in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of lists of length 2. The entire program will be run (for shot count) as many times as there are values in the list. **All values (outer lists) must be of the same length**. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each set of parameters. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_batch(compiled, {\"theta\": [[0.0], [np.pi], [2 * np.pi]]}) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` \"\"\" num_params = None for param_name , param_values in memory_map . items (): if num_params is None : num_params = len ( param_values ) elif num_params != len ( param_values ): raise ValueError ( \"All parameter values must be of the same length. \" f \" { param_name } has length { len ( param_values ) } but { num_params } were expected.\" ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = memory_map ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) combined_result = self . get_result ( AzureJob ( job , executable )) if num_params is None or num_params == 1 : return [ combined_result ] split_results = split ( combined_result . readout_data [ \"ro\" ], num_params ) # type: ignore return [ QAMExecutionResult ( executable , { \"ro\" : result }) for result in split_results ]","title":"run_batch()"},{"location":"api_reference/#pyquil_for_azure_quantum.get_qpu","text":"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def get_qpu ( qpu_name : str ) -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = f \"rigetti.qpu. { qpu_name . lower () } \" , qpu_name = qpu_name )","title":"get_qpu()"},{"location":"api_reference/#pyquil_for_azure_quantum.get_qvm","text":"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Raises: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def get_qvm () -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = \"rigetti.sim.qvm\" , qpu_name = \"qvm\" )","title":"get_qvm()"}]}