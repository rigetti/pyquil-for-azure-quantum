{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyquil-for-azure-quantum This library allows you to use pyQuil to run programs on Azure Quantum against Rigetti targets. Internally, it leverages the azure-quantum package. Usage Generally, you use pyQuil normally, with a few differences: Instead of pyquil.get_qc() , you will use either pyquil_azure_quantum.get_qvm() or pyquil_azure_quantum.get_qpu() . You do not need to have qvm or quilc running in order to run programs through pyquil_azure_quantum . You may still run them if you wish to run QVM locally instead of passing through Azure or if you wish to precompile your programs (e.g., to inspect the exact Quil that will run). You do not need a QCS account or credentials unless you wish to manually inspect the details of the QPU (e.g., list all qubits). You must have these environment variables set: AZURE_QUANTUM_SUBSCRIPTION_ID : The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG : The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME : The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION : The region where the Quantum Workspace is located. You may set environment variables to authenticate with Azure. If you do not, a browser will open to the Azure portal to authenticate. Whenever possible, you should prefer using AzureQuantumComputer.run_batch() over Program.write_memory(); AzureQuantumComputer.run() to run programs which have multiple parameters. Calling write_memory() followed by run() will still work but will be much slower than running a batch of parameters all at once. Examples 1. Leveraging Hosted QVM and quilc With this program, you do not need to run qvm nor quilc locally in order to leverage them, as they can run through Azure Quantum. from pyquil_for_azure_quantum import get_qpu , get_qvm from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) qvm = get_qvm () exe = qpu . compile ( program ) # This does not run quilc yet. results = qpu . run ( exe ) # Quilc will run in the cloud before executing the program. qvm_results = qvm . run ( exe ) # This runs the program on QVM in the cloud, not locally. 2. Running quilc Locally You can optionally run quilc yourself and disable the use of quilc in the cloud. from pyquil_for_azure_quantum import get_qpu from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) native_quil = qpu . compiler . quil_to_native_quil ( program ) # quilc must be running locally to compile exe = qpu . compile ( native_quil , to_native_gates = False ) # Skip quilc in the cloud results = qpu . run ( exe ) 3. Running Parametrized Circuits in a Batch When you have a program which should be run across multiple parameters, you can submit all the parameters at once to significantly improve performance. import numpy as np from pyquil_for_azure_quantum import get_qpu from pyquil.gates import MEASURE , RX from pyquil.quil import Program from pyquil.quilbase import Declare from pyquil.quilatom import MemoryReference program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) compiled = qpu . compile ( program ) memory_map = { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]} results = qpu . run_batch ( compiled , memory_map ) # This is a list of results, one for each parameter set. results_0 = results [ 0 ] . get_register_map () . get ( \"ro\" ) results_pi = results [ 1 ] . get_register_map () . get ( \"ro\" ) results_2pi = results [ 2 ] . get_register_map () . get ( \"ro\" ) Microsoft, Microsoft Azure, and Azure Quantum are trademarks of the Microsoft group of companies.","title":"Home"},{"location":"#pyquil-for-azure-quantum","text":"This library allows you to use pyQuil to run programs on Azure Quantum against Rigetti targets. Internally, it leverages the azure-quantum package.","title":"pyquil-for-azure-quantum"},{"location":"#usage","text":"Generally, you use pyQuil normally, with a few differences: Instead of pyquil.get_qc() , you will use either pyquil_azure_quantum.get_qvm() or pyquil_azure_quantum.get_qpu() . You do not need to have qvm or quilc running in order to run programs through pyquil_azure_quantum . You may still run them if you wish to run QVM locally instead of passing through Azure or if you wish to precompile your programs (e.g., to inspect the exact Quil that will run). You do not need a QCS account or credentials unless you wish to manually inspect the details of the QPU (e.g., list all qubits). You must have these environment variables set: AZURE_QUANTUM_SUBSCRIPTION_ID : The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG : The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME : The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION : The region where the Quantum Workspace is located. You may set environment variables to authenticate with Azure. If you do not, a browser will open to the Azure portal to authenticate. Whenever possible, you should prefer using AzureQuantumComputer.run_batch() over Program.write_memory(); AzureQuantumComputer.run() to run programs which have multiple parameters. Calling write_memory() followed by run() will still work but will be much slower than running a batch of parameters all at once.","title":"Usage"},{"location":"#examples","text":"","title":"Examples"},{"location":"#1-leveraging-hosted-qvm-and-quilc","text":"With this program, you do not need to run qvm nor quilc locally in order to leverage them, as they can run through Azure Quantum. from pyquil_for_azure_quantum import get_qpu , get_qvm from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) qvm = get_qvm () exe = qpu . compile ( program ) # This does not run quilc yet. results = qpu . run ( exe ) # Quilc will run in the cloud before executing the program. qvm_results = qvm . run ( exe ) # This runs the program on QVM in the cloud, not locally.","title":"1. Leveraging Hosted QVM and quilc"},{"location":"#2-running-quilc-locally","text":"You can optionally run quilc yourself and disable the use of quilc in the cloud. from pyquil_for_azure_quantum import get_qpu from pyquil.gates import CNOT , MEASURE , H from pyquil.quil import Program from pyquil.quilbase import Declare program = Program ( Declare ( \"ro\" , \"BIT\" , 2 ), H ( 0 ), CNOT ( 0 , 1 ), MEASURE ( 0 , ( \"ro\" , 0 )), MEASURE ( 1 , ( \"ro\" , 1 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) native_quil = qpu . compiler . quil_to_native_quil ( program ) # quilc must be running locally to compile exe = qpu . compile ( native_quil , to_native_gates = False ) # Skip quilc in the cloud results = qpu . run ( exe )","title":"2. Running quilc Locally"},{"location":"#3-running-parametrized-circuits-in-a-batch","text":"When you have a program which should be run across multiple parameters, you can submit all the parameters at once to significantly improve performance. import numpy as np from pyquil_for_azure_quantum import get_qpu from pyquil.gates import MEASURE , RX from pyquil.quil import Program from pyquil.quilbase import Declare from pyquil.quilatom import MemoryReference program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) qpu = get_qpu ( \"Aspen-11\" ) compiled = qpu . compile ( program ) memory_map = { \"theta\" : [[ 0.0 ], [ np . pi ], [ 2 * np . pi ]]} results = qpu . run_batch ( compiled , memory_map ) # This is a list of results, one for each parameter set. results_0 = results [ 0 ] . get_register_map () . get ( \"ro\" ) results_pi = results [ 1 ] . get_register_map () . get ( \"ro\" ) results_2pi = results [ 2 ] . get_register_map () . get ( \"ro\" ) Microsoft, Microsoft Azure, and Azure Quantum are trademarks of the Microsoft group of companies.","title":"3. Running Parametrized Circuits in a Batch"},{"location":"api_reference/","text":"Run pyquil programs through Azure Quantum Usage: * Instead of using pyquil.get_qc() use pyquil_for_azure_quantum.get_qpu() for QPUs and pyquil_for_azure_quantum.get_qvm() for QVM. * QVM and quilc do not need to be installed or running locally. AzureJob dataclass Keeps track of an AzureProgram that was submitted to Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py @dataclass class AzureJob : \"\"\"Keeps track of an ``AzureProgram`` that was submitted to Azure Quantum.\"\"\" job : Job executable : AzureProgram AzureProgram ( ObjectProxy , Program ) A wrapper around a Program that is used to execute on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py class AzureProgram ( ObjectProxy , Program ): # type: ignore \"\"\"A wrapper around a ``Program`` that is used to execute on Azure Quantum.\"\"\" def __init__ ( self , program : Program , skip_quilc : bool , ) -> None : super () . __init__ ( program ) self . skip_quilc = skip_quilc def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc ) copy ( self ) Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. Source code in pyquil_for_azure_quantum/__init__.py def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc ) AzureQuantumComputer ( QuantumComputer ) A pyquil.QuantumComputer that runs on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py class AzureQuantumComputer ( QuantumComputer ): \"\"\" A ``pyquil.QuantumComputer`` that runs on Azure Quantum. \"\"\" def __init__ ( self , * , target : str , qpu_name : str ): # pylint: disable=abstract-class-instantiated qam = AzureQuantumMachine ( target = target ) compiler = Proxy ( lambda : get_qc ( qpu_name ) . compiler ) super () . __init__ ( name = qpu_name , qam = qam , compiler = compiler ) # pylint: disable-next=unused-argument def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) def run_with_memory_map_batch ( self , # See the comment on the `AzureQuantumComputer` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** __kwargs : Any , ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each ``MemoryMap``. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_with_memory_map_batch(compiled, [{\"theta\": [value]} for value in [0.0, np.pi, 2 * np.pi]}]) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` See Also: * [`AzureQuantumMachine.execute_with_memory_map_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.execute_with_memory_map_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) azure_job = qam . execute_with_memory_map_batch ( executable , memory_maps ) # `execute_with_memory_map_batch` always returns a list of length 1. assert len ( azure_job ) == 1 combined_result = qam . get_result ( azure_job [ 0 ]) # We expect that `memory_maps` is always a list already, so this should # not have a performance impact. num_executions = len ( list ( memory_maps )) if num_executions in ( 0 , 1 ): return [ combined_result ] ro_matrix = combined_result . data . result_data . to_register_map () . get_register_matrix ( \"ro\" ) if ro_matrix is None : return [] return [ QAMExecutionResult ( executable , ExecutionData ( ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = { \"ro\" : RegisterData ( split_result . tolist ())}) ) ), ) for split_result in split ( ro_matrix . to_ndarray (), num_executions ) ] compile ( self , program , to_native_gates = True , optimize = True , * , protoquil = None ) Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass False to to_native_gates . This is necessary when utilizing Quil-T. If you want to run quilc locally in order to check the Native Quil which will be executed, call compiler.quil_to_native_quil and pass the result to this function along with to_native_gates=False . Parameters: Name Type Description Default program Program The program to compile. required to_native_gates bool Whether to convert the program to native gates by running quilc in the cloud prior to execution. Defaults to True , pass False to skip cloud-side quilc . True optimize bool Has no effect on Azure. True protoquil Optional[bool] Has no effect on Azure. None Returns: Type Description AzureProgram An AzureExecutable which is effectively a simple wrapper around a Program . No actual compilation is done here. Source code in pyquil_for_azure_quantum/__init__.py def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) run_with_memory_map_batch ( self , executable , memory_maps , ** _AzureQuantumComputer__kwargs ) Run the executable for each of the memory_maps . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_maps Iterable[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An iterable containing MemoryMaps with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of length 2. The entire program will be run (for shot count) once for each MemoryMap . (If no memory maps are provided, the program will be run once.) required name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description List[pyquil.api._qam.QAMExecutionResult] A list of QAMExecutionResult objects, one for each MemoryMap . >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT , MEASURE , RX , H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm () >>> program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) >>> compiled = qvm . compile ( program ) >>> results = qvm . run_with_memory_map_batch ( compiled , [{ \"theta\" : [ value ]} for value in [ 0.0 , np . pi , 2 * np . pi ]}]) >>> assert len ( results ) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results [ 0 ] . readout_data [ \"ro\" ] >>> assert len ( results_0 ) == 1000 # 1000 shots >>> assert np . mean ( results_0 ) == 0 >>> results_pi = results [ 1 ] . readout_data [ \"ro\" ] >>> assert len ( results_pi ) == 1000 >>> assert np . mean ( results_pi ) == 1 See Also: * AzureQuantumMachine.execute_with_memory_map_batch Source code in pyquil_for_azure_quantum/__init__.py def run_with_memory_map_batch ( self , # See the comment on the `AzureQuantumComputer` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** __kwargs : Any , ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each ``MemoryMap``. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_with_memory_map_batch(compiled, [{\"theta\": [value]} for value in [0.0, np.pi, 2 * np.pi]}]) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` See Also: * [`AzureQuantumMachine.execute_with_memory_map_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.execute_with_memory_map_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) azure_job = qam . execute_with_memory_map_batch ( executable , memory_maps ) # `execute_with_memory_map_batch` always returns a list of length 1. assert len ( azure_job ) == 1 combined_result = qam . get_result ( azure_job [ 0 ]) # We expect that `memory_maps` is always a list already, so this should # not have a performance impact. num_executions = len ( list ( memory_maps )) if num_executions in ( 0 , 1 ): return [ combined_result ] ro_matrix = combined_result . data . result_data . to_register_map () . get_register_matrix ( \"ro\" ) if ro_matrix is None : return [] return [ QAMExecutionResult ( executable , ExecutionData ( ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = { \"ro\" : RegisterData ( split_result . tolist ())}) ) ), ) for split_result in split ( ro_matrix . to_ndarray (), num_executions ) ] AzureQuantumMachine ( QAM ) An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables must be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py class AzureQuantumMachine ( QAM [ AzureJob ]): \"\"\"An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables __must__ be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" def __init__ ( self , * , target : str ) -> None : self . _workspace = Workspace ( subscription_id = environ [ \"AZURE_QUANTUM_SUBSCRIPTION_ID\" ], resource_group = environ [ \"AZURE_QUANTUM_WORKSPACE_RG\" ], name = environ [ \"AZURE_QUANTUM_WORKSPACE_NAME\" ], location = environ [ \"AZURE_QUANTUM_WORKSPACE_LOCATION\" ], ) # noinspection PyTypeChecker self . _target = Rigetti ( workspace = self . _workspace , name = target , ) def execute ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_map : Optional [ MemoryMap ] = None , ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> AzureJob : \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. memory_map: An optional set of parameter names to parameter values to use for execution. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ([ memory_map ]) if memory_map is not None else None , ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () try : result = Result ( job ) except RuntimeError as e : # Most Azure Quantum errors do not include the job ID, so we add it # here for clarity. raise RuntimeError ( f \"Azure job { job . details . id } failed: { e } \" ) from e # pylint: disable-next=fixme # TODO: as of https://github.com/microsoft/qdk-python/blob/4d6f7f75c8c7d8467f87936b1aaef449de1e0bf6/azure-quantum/azure/quantum/target/rigetti/result.py#L47 # both QVM and QC result shapes take the memory-map form as in the QVMResultData. # When the Rigetti target returns results with mappings, the QPUResultData can be constructed. memory = { k : RegisterData ( v ) for k , v in result . data_per_register . items ()} result_data = ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = memory )) data = ExecutionData ( result_data = result_data ) return QAMExecutionResult ( executable = execute_response . executable , data = data , ) def execute_with_memory_map_batch ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> List [ AzureJob ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``AzureJob`` object; because ``AzureJob`` is not considered done until the entire batch is done, this is always a list of length one. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () memory_maps = list ( memory_maps ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ( memory_maps ), ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) azure_job = AzureJob ( job = job , executable = executable ) return [ azure_job ] execute ( self , executable , memory_map = None , ** kwargs ) Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a QuantumExecutable . You should build the AzureProgram via AzureQuantumComputer.compile . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_map Optional[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An optional set of parameter names to parameter values to use for execution. None name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description AzureJob A Job which can be used to check the status of the job or retrieve a QAMExecutionResult via get_result() . Source code in pyquil_for_azure_quantum/__init__.py def execute ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_map : Optional [ MemoryMap ] = None , ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> AzureJob : \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. memory_map: An optional set of parameter names to parameter values to use for execution. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ([ memory_map ]) if memory_map is not None else None , ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) execute_with_memory_map_batch ( self , executable , memory_maps , ** kwargs ) Run the executable for each of the memory_maps . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_maps Iterable[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An iterable containing MemoryMaps with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of length 2. The entire program will be run (for shot count) once for each MemoryMap . (If no memory maps are provided, the program will be run once.) required name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description List[pyquil_for_azure_quantum.AzureJob] A list of AzureJob object; because AzureJob is not considered done until the entire batch is done, this is always a list of length one. Source code in pyquil_for_azure_quantum/__init__.py def execute_with_memory_map_batch ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> List [ AzureJob ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``AzureJob`` object; because ``AzureJob`` is not considered done until the entire batch is done, this is always a list of length one. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () memory_maps = list ( memory_maps ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ( memory_maps ), ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) azure_job = AzureJob ( job = job , executable = executable ) return [ azure_job ] get_result ( self , execute_response ) Wait for a Job to complete, then return the results Exceptions: Type Description RuntimeError If the job fails. Source code in pyquil_for_azure_quantum/__init__.py def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () try : result = Result ( job ) except RuntimeError as e : # Most Azure Quantum errors do not include the job ID, so we add it # here for clarity. raise RuntimeError ( f \"Azure job { job . details . id } failed: { e } \" ) from e # pylint: disable-next=fixme # TODO: as of https://github.com/microsoft/qdk-python/blob/4d6f7f75c8c7d8467f87936b1aaef449de1e0bf6/azure-quantum/azure/quantum/target/rigetti/result.py#L47 # both QVM and QC result shapes take the memory-map form as in the QVMResultData. # When the Rigetti target returns results with mappings, the QPUResultData can be constructed. memory = { k : RegisterData ( v ) for k , v in result . data_per_register . items ()} result_data = ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = memory )) data = ExecutionData ( result_data = result_data ) return QAMExecutionResult ( executable = execute_response . executable , data = data , ) get_qpu ( qpu_name ) Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py def get_qpu ( qpu_name : str ) -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = f \"rigetti.qpu. { qpu_name . lower () } \" , qpu_name = qpu_name ) get_qvm () Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py def get_qvm () -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = RigettiTarget . QVM . value , qpu_name = \"qvm\" )","title":"API Reference"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureJob","text":"Keeps track of an AzureProgram that was submitted to Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py @dataclass class AzureJob : \"\"\"Keeps track of an ``AzureProgram`` that was submitted to Azure Quantum.\"\"\" job : Job executable : AzureProgram","title":"AzureJob"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureProgram","text":"A wrapper around a Program that is used to execute on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py class AzureProgram ( ObjectProxy , Program ): # type: ignore \"\"\"A wrapper around a ``Program`` that is used to execute on Azure Quantum.\"\"\" def __init__ ( self , program : Program , skip_quilc : bool , ) -> None : super () . __init__ ( program ) self . skip_quilc = skip_quilc def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc )","title":"AzureProgram"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureProgram.copy","text":"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. Source code in pyquil_for_azure_quantum/__init__.py def copy ( self ) -> \"AzureProgram\" : \"\"\"Perform a shallow copy of this program. QuilAtom and AbstractInstruction objects should be treated as immutable to avoid strange behavior when performing a copy. \"\"\" return AzureProgram ( self . __wrapped__ . copy (), self . skip_quilc )","title":"copy()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer","text":"A pyquil.QuantumComputer that runs on Azure Quantum. Source code in pyquil_for_azure_quantum/__init__.py class AzureQuantumComputer ( QuantumComputer ): \"\"\" A ``pyquil.QuantumComputer`` that runs on Azure Quantum. \"\"\" def __init__ ( self , * , target : str , qpu_name : str ): # pylint: disable=abstract-class-instantiated qam = AzureQuantumMachine ( target = target ) compiler = Proxy ( lambda : get_qc ( qpu_name ) . compiler ) super () . __init__ ( name = qpu_name , qam = qam , compiler = compiler ) # pylint: disable-next=unused-argument def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates ) def run_with_memory_map_batch ( self , # See the comment on the `AzureQuantumComputer` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** __kwargs : Any , ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each ``MemoryMap``. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_with_memory_map_batch(compiled, [{\"theta\": [value]} for value in [0.0, np.pi, 2 * np.pi]}]) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` See Also: * [`AzureQuantumMachine.execute_with_memory_map_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.execute_with_memory_map_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) azure_job = qam . execute_with_memory_map_batch ( executable , memory_maps ) # `execute_with_memory_map_batch` always returns a list of length 1. assert len ( azure_job ) == 1 combined_result = qam . get_result ( azure_job [ 0 ]) # We expect that `memory_maps` is always a list already, so this should # not have a performance impact. num_executions = len ( list ( memory_maps )) if num_executions in ( 0 , 1 ): return [ combined_result ] ro_matrix = combined_result . data . result_data . to_register_map () . get_register_matrix ( \"ro\" ) if ro_matrix is None : return [] return [ QAMExecutionResult ( executable , ExecutionData ( ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = { \"ro\" : RegisterData ( split_result . tolist ())}) ) ), ) for split_result in split ( ro_matrix . to_ndarray (), num_executions ) ]","title":"AzureQuantumComputer"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer.compile","text":"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass False to to_native_gates . This is necessary when utilizing Quil-T. If you want to run quilc locally in order to check the Native Quil which will be executed, call compiler.quil_to_native_quil and pass the result to this function along with to_native_gates=False . Parameters: Name Type Description Default program Program The program to compile. required to_native_gates bool Whether to convert the program to native gates by running quilc in the cloud prior to execution. Defaults to True , pass False to skip cloud-side quilc . True optimize bool Has no effect on Azure. True protoquil Optional[bool] Has no effect on Azure. None Returns: Type Description AzureProgram An AzureExecutable which is effectively a simple wrapper around a Program . No actual compilation is done here. Source code in pyquil_for_azure_quantum/__init__.py def compile ( self , program : Program , to_native_gates : bool = True , optimize : bool = True , * , protoquil : Optional [ bool ] = None , ) -> AzureProgram : \"\"\"Compile a program for Azure execution. By default, this stage is a no-op and is here for better compatibility with pyquil programs. Azure will do all compilation in the cloud. However, if you want to tell Azure to skip the quilc step, pass ``False`` to ``to_native_gates``. This is necessary when utilizing Quil-T. If you want to run ``quilc`` locally in order to check the Native Quil which will be executed, call ``compiler.quil_to_native_quil`` and pass the result to this function along with ``to_native_gates=False``. Args: program: The program to compile. to_native_gates: Whether to convert the program to native gates by running ``quilc`` *in the cloud* prior to execution. Defaults to ``True``, pass ``False`` to skip cloud-side ``quilc``. optimize: Has no effect on Azure. protoquil: Has no effect on Azure. Returns: An ``AzureExecutable`` which is effectively a simple wrapper around a ``Program``. No actual compilation is done here. \"\"\" return AzureProgram ( program , skip_quilc = not to_native_gates )","title":"compile()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumComputer.run_with_memory_map_batch","text":"Run the executable for each of the memory_maps . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_maps Iterable[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An iterable containing MemoryMaps with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of length 2. The entire program will be run (for shot count) once for each MemoryMap . (If no memory maps are provided, the program will be run once.) required name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description List[pyquil.api._qam.QAMExecutionResult] A list of QAMExecutionResult objects, one for each MemoryMap . >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT , MEASURE , RX , H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm () >>> program = Program ( Declare ( \"ro\" , \"BIT\" , 1 ), Declare ( \"theta\" , \"REAL\" , 1 ), RX ( MemoryReference ( \"theta\" ), 0 ), MEASURE ( 0 , ( \"ro\" , 0 )), ) . wrap_in_numshots_loop ( 1000 ) >>> compiled = qvm . compile ( program ) >>> results = qvm . run_with_memory_map_batch ( compiled , [{ \"theta\" : [ value ]} for value in [ 0.0 , np . pi , 2 * np . pi ]}]) >>> assert len ( results ) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results [ 0 ] . readout_data [ \"ro\" ] >>> assert len ( results_0 ) == 1000 # 1000 shots >>> assert np . mean ( results_0 ) == 0 >>> results_pi = results [ 1 ] . readout_data [ \"ro\" ] >>> assert len ( results_pi ) == 1000 >>> assert np . mean ( results_pi ) == 1 See Also: * AzureQuantumMachine.execute_with_memory_map_batch Source code in pyquil_for_azure_quantum/__init__.py def run_with_memory_map_batch ( self , # See the comment on the `AzureQuantumComputer` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** __kwargs : Any , ) -> List [ QAMExecutionResult ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``QAMExecutionResult`` objects, one for each ``MemoryMap``. ```pycon >>> import numpy as np >>> from pyquil import Program >>> from pyquil.gates import CNOT, MEASURE, RX, H >>> from pyquil.quilatom import MemoryReference >>> from pyquil.quilbase import Declare >>> from pyquil_for_azure_quantum import get_qvm >>> qvm = get_qvm() >>> program = Program(\\ Declare(\"ro\", \"BIT\", 1), \\ Declare(\"theta\", \"REAL\", 1), \\ RX(MemoryReference(\"theta\"), 0), \\ MEASURE(0, (\"ro\", 0)), \\ ).wrap_in_numshots_loop(1000) >>> compiled = qvm.compile(program) >>> results = qvm.run_with_memory_map_batch(compiled, [{\"theta\": [value]} for value in [0.0, np.pi, 2 * np.pi]}]) >>> assert len(results) == 3 # 3 values for theta\u2014each a list of length 1 >>> results_0 = results[0].readout_data[\"ro\"] >>> assert len(results_0) == 1000 # 1000 shots >>> assert np.mean(results_0) == 0 >>> results_pi = results[1].readout_data[\"ro\"] >>> assert len(results_pi) == 1000 >>> assert np.mean(results_pi) == 1 ``` See Also: * [`AzureQuantumMachine.execute_with_memory_map_batch`][pyquil_for_azure_quantum.AzureQuantumMachine.execute_with_memory_map_batch] \"\"\" qam = cast ( AzureQuantumMachine , self . qam ) azure_job = qam . execute_with_memory_map_batch ( executable , memory_maps ) # `execute_with_memory_map_batch` always returns a list of length 1. assert len ( azure_job ) == 1 combined_result = qam . get_result ( azure_job [ 0 ]) # We expect that `memory_maps` is always a list already, so this should # not have a performance impact. num_executions = len ( list ( memory_maps )) if num_executions in ( 0 , 1 ): return [ combined_result ] ro_matrix = combined_result . data . result_data . to_register_map () . get_register_matrix ( \"ro\" ) if ro_matrix is None : return [] return [ QAMExecutionResult ( executable , ExecutionData ( ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = { \"ro\" : RegisterData ( split_result . tolist ())}) ) ), ) for split_result in split ( ro_matrix . to_ndarray (), num_executions ) ]","title":"run_with_memory_map_batch()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine","text":"An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables must be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py class AzureQuantumMachine ( QAM [ AzureJob ]): \"\"\"An implementation of QAM which runs programs using Azure Quantum These Azure Quantum configuration environment variables __must__ be set: * AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. * AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. * AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. Credentials for communicating with Azure Quantum should be stored in the following environment variables. If they are not set, this will attempt to open a browser to authenticate: * AZURE_CLIENT_ID * AZURE_CLIENT_SECRET * AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" def __init__ ( self , * , target : str ) -> None : self . _workspace = Workspace ( subscription_id = environ [ \"AZURE_QUANTUM_SUBSCRIPTION_ID\" ], resource_group = environ [ \"AZURE_QUANTUM_WORKSPACE_RG\" ], name = environ [ \"AZURE_QUANTUM_WORKSPACE_NAME\" ], location = environ [ \"AZURE_QUANTUM_WORKSPACE_LOCATION\" ], ) # noinspection PyTypeChecker self . _target = Rigetti ( workspace = self . _workspace , name = target , ) def execute ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_map : Optional [ MemoryMap ] = None , ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> AzureJob : \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. memory_map: An optional set of parameter names to parameter values to use for execution. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ([ memory_map ]) if memory_map is not None else None , ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable ) def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () try : result = Result ( job ) except RuntimeError as e : # Most Azure Quantum errors do not include the job ID, so we add it # here for clarity. raise RuntimeError ( f \"Azure job { job . details . id } failed: { e } \" ) from e # pylint: disable-next=fixme # TODO: as of https://github.com/microsoft/qdk-python/blob/4d6f7f75c8c7d8467f87936b1aaef449de1e0bf6/azure-quantum/azure/quantum/target/rigetti/result.py#L47 # both QVM and QC result shapes take the memory-map form as in the QVMResultData. # When the Rigetti target returns results with mappings, the QPUResultData can be constructed. memory = { k : RegisterData ( v ) for k , v in result . data_per_register . items ()} result_data = ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = memory )) data = ExecutionData ( result_data = result_data ) return QAMExecutionResult ( executable = execute_response . executable , data = data , ) def execute_with_memory_map_batch ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> List [ AzureJob ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``AzureJob`` object; because ``AzureJob`` is not considered done until the entire batch is done, this is always a list of length one. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () memory_maps = list ( memory_maps ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ( memory_maps ), ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) azure_job = AzureJob ( job = job , executable = executable ) return [ azure_job ]","title":"AzureQuantumMachine"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.execute","text":"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a QuantumExecutable . You should build the AzureProgram via AzureQuantumComputer.compile . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_map Optional[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An optional set of parameter names to parameter values to use for execution. None name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description AzureJob A Job which can be used to check the status of the job or retrieve a QAMExecutionResult via get_result() . Source code in pyquil_for_azure_quantum/__init__.py def execute ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_map : Optional [ MemoryMap ] = None , ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> AzureJob : \"\"\"Run an AzureProgram on Azure Quantum. Unlike normal QAM this does not accept a ``QuantumExecutable``. You should build the ``AzureProgram`` via ``AzureQuantumComputer.compile``. Args: executable: The AzureProgram to run. memory_map: An optional set of parameter names to parameter values to use for execution. name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A ``Job`` which can be used to check the status of the job or retrieve a ``QAMExecutionResult`` via ``get_result()``. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ([ memory_map ]) if memory_map is not None else None , ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) return AzureJob ( job = job , executable = executable )","title":"execute()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.execute_with_memory_map_batch","text":"Run the executable for each of the memory_maps . Parameters: Name Type Description Default executable AzureProgram The AzureProgram to run. required memory_maps Iterable[collections.abc.Mapping[str, Union[collections.abc.Sequence[int], collections.abc.Sequence[float]]]] An iterable containing MemoryMaps with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was DECLARE theta REAL[2] then the key in the dictionary would be theta and the value would be a list of length 2. The entire program will be run (for shot count) once for each MemoryMap . (If no memory maps are provided, the program will be run once.) required name An optional name for the job which will show up in the Azure Quantum UI. required Returns: Type Description List[pyquil_for_azure_quantum.AzureJob] A list of AzureJob object; because AzureJob is not considered done until the entire batch is done, this is always a list of length one. Source code in pyquil_for_azure_quantum/__init__.py def execute_with_memory_map_batch ( self , # See the comment on the `AzureQuantumMachine` class for why the type error is ignored. executable : AzureProgram , # type: ignore[override] memory_maps : Iterable [ MemoryMap ], ** kwargs : Any , # used for `name`, to ensure signature compatibility with QAM ) -> List [ AzureJob ]: \"\"\"Run the executable for each of the ``memory_maps``. Args: executable: The AzureProgram to run. memory_maps: An iterable containing ``MemoryMaps`` with desired mappings of parameter names to parameter values. Each value is a list as long as the number of elements in the register. So if the register was ``DECLARE theta REAL[2]`` then the key in the dictionary would be ``theta`` and the value would be a list of length 2. The entire program will be run (for shot count) once for each ``MemoryMap``. (If no memory maps are provided, the program will be run once.) name: An optional name for the job which will show up in the Azure Quantum UI. Returns: A list of ``AzureJob`` object; because ``AzureJob`` is not considered done until the entire batch is done, this is always a list of length one. \"\"\" name = kwargs . get ( \"name\" , \"pyquil-azure-job\" , ) executable = executable . copy () memory_maps = list ( memory_maps ) input_params = InputParams ( count = executable . num_shots , skip_quilc = executable . skip_quilc , substitutions = _make_substitutions_from_memory_maps ( memory_maps ), ) job = self . _target . submit ( str ( executable ), name = name , input_params = input_params , ) azure_job = AzureJob ( job = job , executable = executable ) return [ azure_job ]","title":"execute_with_memory_map_batch()"},{"location":"api_reference/#pyquil_for_azure_quantum.AzureQuantumMachine.get_result","text":"Wait for a Job to complete, then return the results Exceptions: Type Description RuntimeError If the job fails. Source code in pyquil_for_azure_quantum/__init__.py def get_result ( self , execute_response : AzureJob ) -> QAMExecutionResult : \"\"\"Wait for a ``Job`` to complete, then return the results Raises: RuntimeError: If the job fails. \"\"\" job = execute_response . job job . wait_until_completed () try : result = Result ( job ) except RuntimeError as e : # Most Azure Quantum errors do not include the job ID, so we add it # here for clarity. raise RuntimeError ( f \"Azure job { job . details . id } failed: { e } \" ) from e # pylint: disable-next=fixme # TODO: as of https://github.com/microsoft/qdk-python/blob/4d6f7f75c8c7d8467f87936b1aaef449de1e0bf6/azure-quantum/azure/quantum/target/rigetti/result.py#L47 # both QVM and QC result shapes take the memory-map form as in the QVMResultData. # When the Rigetti target returns results with mappings, the QPUResultData can be constructed. memory = { k : RegisterData ( v ) for k , v in result . data_per_register . items ()} result_data = ResultData . from_qvm ( QVMResultData . from_memory_map ( memory = memory )) data = ExecutionData ( result_data = result_data ) return QAMExecutionResult ( executable = execute_response . executable , data = data , )","title":"get_result()"},{"location":"api_reference/#pyquil_for_azure_quantum.get_qpu","text":"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py def get_qpu ( qpu_name : str ) -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a real QPU These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = f \"rigetti.qpu. { qpu_name . lower () } \" , qpu_name = qpu_name )","title":"get_qpu()"},{"location":"api_reference/#pyquil_for_azure_quantum.get_qvm","text":"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables must be set: AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: AZURE_CLIENT_ID AZURE_CLIENT_SECRET AZURE_TENANT_ID Exceptions: Type Description KeyError If required environment variables are not set. Source code in pyquil_for_azure_quantum/__init__.py def get_qvm () -> AzureQuantumComputer : \"\"\"Get an AzureQuantumComputer targeting a cloud-hosted QVM These Azure Quantum configuration environment variables __must__ be set: - AZURE_QUANTUM_SUBSCRIPTION_ID: The Azure subscription ID where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_RG: The Azure resource group where the Quantum Workspace is located. - AZURE_QUANTUM_WORKSPACE_NAME: The name of the Quantum Workspace. - AZURE_QUANTUM_WORKSPACE_LOCATION: The region where the Quantum Workspace is located. If these are not set, this will attempt to open a browser to authenticate: - AZURE_CLIENT_ID - AZURE_CLIENT_SECRET - AZURE_TENANT_ID Raises: KeyError: If required environment variables are not set. \"\"\" return AzureQuantumComputer ( target = RigettiTarget . QVM . value , qpu_name = \"qvm\" )","title":"get_qvm()"}]}